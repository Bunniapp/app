"use strict";(self.webpackChunkinterface=self.webpackChunkinterface||[]).push([[959],{6959:(Z,m,t)=>{t.r(m),t.d(m,{ccipRequest:()=>x,offchainLookup:()=>D,offchainLookupAbiItem:()=>R,offchainLookupSignature:()=>j});var g=t(5861),k=t(9934),L=t(38),d=t(2618),b=t(1448);class G extends d.G{constructor({callbackSelector:e,cause:r,data:c,extraData:i,sender:u,urls:n}){super(r.shortMessage||"An error occurred while fetching for an offchain result.",{cause:r,metaMessages:[...r.metaMessages||[],r.metaMessages?.length?"":[],"Offchain Gateway Call:",n&&["  Gateway URL(s):",...n.map(f=>`    ${(0,b.Gr)(f)}`)],`  Sender: ${u}`,`  Data: ${c}`,`  Callback selector: ${e}`,`  Extra data: ${i}`].flat()}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"OffchainLookupError"})}}class M extends d.G{constructor({result:e,url:r}){super("Offchain gateway response is malformed. Response data must be a hex value.",{metaMessages:[`Gateway URL: ${(0,b.Gr)(r)}`,`Response: ${(0,L.P)(e)}`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"OffchainLookupResponseMalformedError"})}}class S extends d.G{constructor({sender:e,to:r}){super("Reverted sender address does not match target contract address (`to`).",{metaMessages:[`Contract address: ${r}`,`OffchainLookup sender address: ${e}`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"OffchainLookupSenderMismatchError"})}}var v=t(3979),$=t(1936),C=t(2910),O=t(8355),w=t(9526),A=t(770),T=t(7812);const j="0x556f1830",R={name:"OffchainLookup",type:"error",inputs:[{name:"sender",type:"address"},{name:"urls",type:"string[]"},{name:"callData",type:"bytes"},{name:"callbackFunction",type:"bytes4"},{name:"extraData",type:"bytes"}]};function D(a,e){return l.apply(this,arguments)}function l(){return(l=(0,g.Z)(function*(a,{blockNumber:e,blockTag:r,data:c,to:i}){const{args:u}=(0,$.p)({data:c,abi:[R]}),[n,f,s,o,E]=u,{ccipRead:p}=a,U=p&&"function"==typeof p?.request?p.request:x;try{if(!function P(a,e){if(!(0,w.U)(a,{strict:!1}))throw new O.b({address:a});if(!(0,w.U)(e,{strict:!1}))throw new O.b({address:e});return a.toLowerCase()===e.toLowerCase()}(i,n))throw new S({sender:n,to:i});const y=yield U({data:s,sender:n,urls:f}),{data:I}=yield(0,k.RE)(a,{blockNumber:e,blockTag:r,data:(0,A.zo)([o,(0,C.E)([{type:"bytes"},{type:"bytes"}],[y,E])]),to:i});return I}catch(y){throw new G({callbackSelector:o,cause:y,data:c,extraData:E,sender:n,urls:f})}})).apply(this,arguments)}function x(a){return h.apply(this,arguments)}function h(){return(h=(0,g.Z)(function*({data:a,sender:e,urls:r}){let c=new Error("An unknown error occurred.");for(let i=0;i<r.length;i++){const u=r[i],n=u.includes("{data}")?"GET":"POST",f="POST"===n?{data:a,sender:e}:void 0;try{const s=yield fetch(u.replace("{sender}",e).replace("{data}",a),{body:JSON.stringify(f),method:n});let o;if(o=s.headers.get("Content-Type")?.startsWith("application/json")?(yield s.json()).data:yield s.text(),!s.ok){c=new v.Gg({body:f,details:o?.error?(0,L.P)(o.error):s.statusText,headers:s.headers,status:s.status,url:u});continue}if(!(0,T.v)(o)){c=new M({result:o,url:u});continue}return o}catch(s){c=new v.Gg({body:f,details:s.message,url:u})}}throw c})).apply(this,arguments)}}}]);